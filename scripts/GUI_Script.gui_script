local TILE_SIZE = 89       --your tile size
local TILE = {
	x = 8,
	y = 8
} -- x and y of tile
local ROBOT_ONE = {
	tile = 0,
	alive = true,
	hasAction = false,
	isSelected = false,
	canMove = false,
	validMoves = {},
	tileOn = "ground"
}
local ROBOT_TWO = {
	tile = 0,
	alive = false,
	hasAction = false,
	isSelected = false,
	canMove = false,
	validMoves = {}
}
local ROBOT_THREE = {
	tile = 0,
	alive = false,
	hasAction = false,
	isSelected = false,
	canMove = false,
	validMoves = {}
}
local GOOD_PLANT = {
	x = 345,
	y = 1160
}
allowClick = false
local poisonThisRound = 0
local enemyTiles = {55}
local moveTiles = {-2,-1,1,2,9,-9,8,-8,7,-7,-16,16}
local validMoves = {}
local startTiles = {1,2,3,9,11,17,18,19}
function init(self)
	self.turn = 1
	self.turnType = "enemy"
	allowClick = false
	self.placedFirstRobot = false
	self.yellow = vmath.vector3(255,255,204)
	self.white = vmath.vector3(255,255,255)
	msg.post(".", "acquire_input_focus")
end

function update(self, dt)
	gui.set_text(gui.get_node("turns"), "Turn " .. tostring(self.turn))
	if self.lost then
		local lostNode = gui.get_node("lost")
		gui.set_enabled(lostNode, true)
		gui.set_visible(lostNode, true)
	end
	if gui.get_flipbook(gui.get_node("55")) == hash("robotTile") then
		local wonNode = gui.get_node("won")
		gui.set_enabled(wonNode, true)
		gui.set_visible(wonNode, true)
	end
	if not ROBOT_ONE.canMove and not ROBOT_TWO.canMove and not ROBOT_THREE.canMove then
		ROBOT_ONE.hasAction = true
		ROBOT_TWO.hasAction = true
		ROBOT_THREE.hasAction = true
	end
	if self.placedFirstRobot then
		if self.turnType == "enemy" then
			gui.set_color(gui.get_node("enemyTurn"), self.yellow)
			gui.set_color(gui.get_node("action"), self.white)
			poisonNum = 0
			while poisonNum < 1 do
				local num = placePoison()
				poisonNum = poisonNum + num
			end
			poisonThisRound = 0
			allowClick = true
			self.turnType = "move"
			ROBOT_ONE.canMove = true
			--ROBOT_TWO.canMove = true
			--ROBOT_THREE.canMove = true
			self.lost = check_if_lost()
		end
		if self.turnType == "action" then
			gui.set_color(gui.get_node("action"), self.yellow)
			gui.set_color(gui.get_node("move"), self.white)
		end
		if self.turnType == "move" then
			gui.set_color(gui.get_node("move"), self.yellow)
			gui.set_color(gui.get_node("enemyTurn"), self.white)
		end
	end
end

function placePoison()
	local loc = math.random(1,4)
	local index = math.random(1,#enemyTiles)
	local closestEnemy = enemyTiles[index]
	if loc == 1 then
		local num = do_poison(closestEnemy - 8)
		return num
	end
	if loc == 2 then
		local num = do_poison(closestEnemy + 1)
		return num
	end
	if loc == 3 then
		local num = do_poison(closestEnemy + 8)
		return num
	end
	if loc == 4 then
		local num = do_poison(closestEnemy - 1)
		return num
	end
	return 0
end

function check_if_lost()
	local poisonCount = 0
	for i = 1, #startTiles do
		if poisonCount > 1 then
			allowClick = false
			return true
		end
		if gui.get_flipbook(gui.get_node(tostring(startTiles[i]))) == hash("poison") then
			poisonCount = poisonCount + 1
		end
	end
	return false
end

function do_poison(id)
	if id < 65 and id > 0 then
		local node = gui.get_node(tostring(id))
		local flipbook = gui.get_flipbook(node)
		if not flipbook == hash("ground") then
			return 0
		end
		if flipbook == hash("ground") then
			gui.play_flipbook(node, hash("poison"))
			table.insert(enemyTiles,id)
			return 1
		end
	end
	return 0
end

function on_message(self, message_id, message, sender)
	-- if message_id == hash("load_level") then
	-- 	print("LOAD LEVEL")
	-- 	msg.post(message.proxy, "load")
	-- end
	-- elseif message_id == hash("clear_level") then
	-- 	print("CLEAR LEVEL")
	-- 	msg.post(message.proxy, "disable")
	-- 	msg.post(message.proxy, "final")
	-- 	msg.post(message.proxy, "unload")
	-- end
end

function validate_move()

end

function save_valid_moves(robot)
	local tile = robot.tile
	robot.validMoves = {}
	if tile > 8 then
		table.insert(robot.validMoves,-8)
		if tile%8 > 0 then
			table.insert(robot.validMoves, -7)
		end
		if tile%8 > 1 then
			table.insert(robot.validMoves, -9)
		end
	end
	if tile < 57 then
		table.insert(robot.validMoves,8)
		if (not (tile%8 == 1)) and (tile%8 < 8 or tile%8 == 0) then
			table.insert(robot.validMoves, 7)
		end
		if tile%8 < 8 and tile%8 > 0 then
			table.insert(robot.validMoves, 9)
		end
	end
	if tile%8 > 1 then
		table.insert(robot.validMoves, -1)
	end
	if tile%8 > 2 then
		table.insert(robot.validMoves, -2)
	end
	if tile > 16 then
		table.insert(robot.validMoves, -16)
	end
	if tile%8 > 0 then
		table.insert(robot.validMoves, 1)
	end
	if tile%8 > 0 and tile%8 < 7 then
		table.insert(robot.validMoves, 2)
	end
	if tile < 49 then
		table.insert(robot.validMoves, 16)
	end
end

function on_input(self, action_id, action)
	popNode = gui.get_node("popup")
	if action_id == hash("touch") and action.pressed then
		if gui.pick_node(gui.get_node("soundsGood"), action.x, action.y) then
			gui.set_enabled(popNode, false)
			gui.set_visible(popNode, false)
			msg.post("background#main", "down")
			allowClick = true
		end

		if gui.pick_node(gui.get_node("endTurn"), action.x, action.y) and self.turnType == "action" then
			self.turnType = "enemy"		
			self.turn = self.turn + 1	
		end	
		if allowClick then
			if self.placedFirstRobot and (gui.pick_node(gui.get_node(tostring(ROBOT_ONE.tile)), action.x, action.y)) then
				ROBOT_ONE.isSelected = true
			end
			if self.placedFirstRobot and (gui.pick_node(gui.get_node("cleanup"), action.x, action.y)) and ROBOT_ONE.isSelected and ROBOT_ONE.hasAction then
				if self.turnType == "action" and gui.get_flipbook(gui.get_node(tostring(ROBOT_ONE.tile))) == hash("robotOnPoison") then
					gui.play_flipbook(gui.get_node(tostring(ROBOT_ONE.tile)), hash("robotTile"))
					ROBOT_ONE.hasAction = false
					table.remove(enemyTiles,ROBOT_ONE.tile)
				end
			end
			for i = 1, 64 do 
				local validMove = false
				local node = gui.get_node(tostring(i))
				if(gui.pick_node(node, action.x, action.y)) then
					-- "tempTileSource/badPlant"
					local flipbook = gui.get_flipbook(node)
					if self.placedFirstRobot and (ROBOT_ONE.isSelected or ROBOT_TWO.isSelected or ROBOT_THREE.isSelected) and ROBOT_ONE.canMove then
						if self.turnType == "move" then
							for j=1,#ROBOT_ONE.validMoves do
								if ROBOT_ONE.validMoves[j] + ROBOT_ONE.tile == i then
									validMove = true
								end
							end
							if flipbook == hash("ground") and validMove then
								gui.play_flipbook(gui.get_node(tostring(ROBOT_ONE.tile)), hash("ground"))
								gui.play_flipbook(node, hash("robotTile"))
								ROBOT_ONE.tile = i
								ROBOT_ONE.isSelected = false
								ROBOT_ONE.canMove = false
								save_valid_moves(ROBOT_ONE)
								self.turnType = "action"
								return
							end
							if validMove and flipbook == hash("poison") or flipbook == hash("badPlant") then
								gui.play_flipbook(gui.get_node(tostring(ROBOT_ONE.tile)), hash("ground"))
								gui.play_flipbook(node, hash("robotOnPoison"))
								ROBOT_ONE.tile = i
								ROBOT_ONE.isSelected = false
								ROBOT_ONE.canMove = false
								save_valid_moves(ROBOT_ONE)
								self.turnType = "action"
								return
							end
						end
					end
					if flipbook == hash("ground") then
						if not self.placedFirstRobot then
							for j = 1, #startTiles do
								if startTiles[j] == i then
									gui.play_flipbook(node, hash("robotTile"))
									self.placedFirstRobot = true
									ROBOT_ONE.tile = i
									allowClick = false
									save_valid_moves(ROBOT_ONE)
								end
							end
						end
					end
					break
				end
			end
		end
		-- if gui.pick_node(gui.get_node("restart"), action.x, action.y) then
		-- 	msg.post("main:/game#levelProxies", "clear_level", { proxy = "/game#level1Proxy" })
		-- 	msg.post("main:/game#levelProxies", "load_level", { proxy = "/game#level1Proxy" })
		-- end
	end
end