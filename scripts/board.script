go.property("timer", 0)     -- Use to time events
local dtile = require "dtile.dtile"
local blocksize = 96        -- Distance between block centers
local edge = 100             -- Left and right edge.
local bottom_edge = 100      -- Bottom edge.
local boardwidth = 9        -- Number of columns
local boardheight = 9       -- Number of rows
day = 0
end_of_game = false
local can_click = true
local pathtiles = { 
	{0,1,5,6,7,8},
	{1,3,5},
	{1,2,3,4,5,6,7},
	{1,5,7},
	{1,3,5,7},
	{1,3,7},
	{0,1,2,3,4,5,6,7,8},
	{0,2,4,6},
	{2,6}
}
local plots = { 
	plot1 = {{x=1,y=2},{x=1,y=3},{x=1,y=4},{x=1,y=5},{x=1,y=6}},
	plot2 = {{x=3,y=1},{x=3,y=2},{x=4,y=1},{x=5,y=1},{x=5,y=2}},
	plot3 = {{x=3,y=6},{x=3,y=5},{x=3,y=4},{x=4,y=4},{x=5,y=4},{x=5,y=5},{x=5,y=6},{x=6,y=6},{x=7,y=6},{x=7,y=5},{x=7,y=4}},
	plot4 = {{x=7,y=2},{x=8,y=2},{x=9,y=2},{x=9,y=3},{x=9,y=4},{x=9,y=5},{x=9,y=6}},
	plot5 = {{x=1,y=9},{x=2,y=9},{x=2,y=8}},
	plot6 = {{x=4,y=8},{x=4,y=9},{x=5,y=9},{x=6,y=9},{x=6,y=8}}
}
local goodorbadplant = { hash("good-plant-placeholder"), hash("generic_bad_plant")}
local badplantchoices = { hash("poison_plant_placeholder"), hash("electric-plant-placeholder"), hash("explosive_plant_placeholder")} 
turn = "move"
selected_robot_index = 0
max_num_pesticide = 1
max_num_steroids = 1
max_num_fertilizer = 1
num_pesticide = 1
num_steroids = 1
num_fertilizer = 1
in_shed = {true, true, true}

function init(self)
	self.board = {}             -- Contains the board structure
	self.blocks = {}            -- List of all blocks. Used for easy filtering on selection.
	self.robots = {}
	self.goodplants = {}
	self.badplants = {}
	self.emptyplots = {}
	self.highlighted_block = {}
	self.robot_items_left = {}
	msg.post(".", "acquire_input_focus")
	build_board(self)
	prepare_robots(self)
	show_starting_info(self)
end

local function filter(func, tbl)
	local new = {}
	for i, v in pairs(tbl) do
		if func(v) then
			new[i] = v
		end
	end
	return new
end

function update(self, dt)
	for i, robot in ipairs(self.robots) do
		local actual_robot = robot.id
		local pos = go.get_position(actual_robot)
		local x = math.floor((pos.x - edge) / blocksize)
		local y = math.floor((pos.y - bottom_edge) / blocksize)
		if is_on_shed(self,x,y) then
			msg.post(actual_robot, "hide")
			msg.post(actual_robot, "hide_item")
			in_shed[i] = true
		else
			msg.post(actual_robot, "show")
			msg.post(actual_robot, "show_item")
			in_shed[i] = false
		end
	end
	if turn == "move" then
		check_if_enemy_turn(self)
	end
end

function check_if_enemy_turn(self)
	local playable_move = false
	if self.robots[1].can_move or self.robots[2].can_move or self.robots[3].can_move then
		playable_move = true
	elseif (num_steroids > 0 or any_robots_have_item(self, "brassinosteroids-placeholder")) and 
	is_block_on_board(self, "good-plant-placeholder") then 
		playable_move = true
	elseif (num_pesticide > 0 or any_robots_have_item(self, "pesticide_placeholder")) and 
	(is_block_on_board(self, "electric-plant-placeholder") or 
	is_block_on_board(self, "generic_bad_plant") or 
	is_block_on_board(self, "explosive_plant_placeholder") or 
	is_block_on_board(self, "poison_plant_placeholder")) then
		playable_move = true
	elseif (num_fertilizer > 0 or any_robots_have_item(self, "fertilizer_placeholder")) and
	(is_block_on_board(self, "dirt-placeholder") or 
	is_block_on_board(self, "dirt-poisoned")) then
		playable_move = true
	end
	if not playable_move then
		turn = "enemy_turn"
		check_if_win_day(self)
		get_rid_of_shocks(self)
		start_enemy_turn(self)
	end	
end	

function get_rid_of_shocks(self)
	for i, robot in ipairs(self.robots) do
		if is_robot_holding_item(self, "stunEffect", i) then
			return true
		end
	end	
end	

function any_robots_have_item(self, item)
	for i, robot in ipairs(self.robots) do
		if is_robot_holding_item(self, item, i) then
			return true
		end	
	end
	return false	
end	

function is_block_on_board(self, block)
	for i, tile in ipairs(self.tiles) do
		if tile.plot_instance == block then
			return true
		end	
	end	
	return false
end	

--
-- Build a list of blocks in 1 dimension for easy filtering
--
local function build_tilelist(self)
	self.tiles = {}
	self.goodplants = {}
	self.badplants = {}
	self.emptyplots = {}
	for y, l in pairs(self.board) do
		for x, b in pairs(self.board[y]) do
			table.insert(self.tiles, { id = b.id, plot_instance = b.plot_instance, x = b.x, y = b.y })
			if b.plot_instance == hash("good-plant-placeholder") then
				table.insert(self.goodplants, { id = b.id, plot_instance = b.plot_instance, x = b.x, y = b.y })
			elseif b.plot_instance == hash("electric-plant-placeholder") or 
			b.plot_instance == hash("generic_bad_plant") or 
			b.plot_instance == hash("explosive_plant_placeholder") or
			b.plot_instance == hash("poison_plant_placeholder") then
				table.insert(self.badplants, { id = b.id, plot_instance = b.plot_instance, x = b.x, y = b.y })
			elseif b.plot_instance == hash("dirt-placeholder") or 
			b.plot_instance == hash("dirt-poisoned") or 
			b.plot_instance == hash("fertilized-dirt") then
				table.insert(self.emptyplots, { id = b.id, plot_instance = b.plot_instance, x = b.x, y = b.y })
			end
		end
	end
end
-- 
function on_input(self, action_id, action)
	local x = math.floor((action.x - edge) / blocksize)
	local y = math.floor((action.y - bottom_edge) / blocksize)
	if not action_id and can_click then
		if turn == "move" then
			update_highlights(self, x, y)			
		elseif turn == "enemy_turn" then
			
		end
	end
	if action_id == hash("touch") and action.pressed and can_click then
		if turn == "move" then
			if self.board and self.board[y] and self.board[y][x] then
				if (self.board[y][x].plot_instance == hash("path-placeholder") 
					or is_on_shed(self,x,y))
					and self.robots[selected_robot_index] 
					and not (self.robots[selected_robot_index]).moving then
					self.robots[selected_robot_index].moving = true
					move_robot(self, self.board[y][x])
				elseif can_use_pesticide(self,x,y) and is_next_to_plot(self,x,y) then
					update_plots_on_action(self, x, y, "dirt-placeholder")
				elseif can_use_fertilizer(self,x,y) and is_next_to_plot(self,x,y) then
					local texture = nil
					if self.board[y][x].plot_instance == hash("dirt-placeholder") then
						texture = "fertilized-dirt"
					elseif self.board[y][x].plot_instance == hash("dirt-poisoned") then
						texture = "dirt-placeholder"
					end
					print(texture)
					update_plots_on_action(self, x, y, texture)
				elseif can_use_steroids(self,x,y) and is_next_to_plot(self,x,y) then
					update_plots_on_action(self, x, y, "good-plant-steroids-placeholder")
				end
			end	
		end
	end
	build_tilelist(self)
end

function update_plots_on_action(self, x, y, texture)
	self.board[y][x].plot_instance = hash(texture)
	go.set(msg.url(nil, self.board[y][x].id, "tile"), hash("plot_instance"), hash(texture))
	msg.post(self.board[y][x].id, "play_flipbook", {id = hash(texture)})
	msg.post(self.robots[selected_robot_index].id, "remove_item")
	self.robots[selected_robot_index].can_move = false
	msg.post("game:/infoGUI", "remove_item")
end	

function update_highlights(self, x, y)
	if self.board and self.board[y] and self.board[y][x] and self.robots[selected_robot_index] then
		p = go.get_position(self.board[y][x].id)
		if (self.board[y][x].plot_instance == hash("generic_bad_plant") or 
		self.board[y][x].plot_instance == hash("electric-plant-placeholder") or 
		self.board[y][x].plot_instance == hash("explosive_plant_placeholder") or 
		self.board[y][x].plot_instance == hash("poison_plant_placeholder"))
		and is_robot_holding_item(self, "pesticide_placeholder", selected_robot_index) then
			handle_highlight(self, "#plotHighlight", "plot", x, y)
		elseif (self.board[y][x].plot_instance == hash("dirt-placeholder") or self.board[y][x].plot_instance == hash("dirt-poisoned"))
		and is_robot_holding_item(self, "fertilizer-placeholder", selected_robot_index) then
			handle_highlight(self, "#plotHighlight", "plot", x, y)
		elseif self.board[y][x].plot_instance == hash("good-plant-placeholder")
		and is_robot_holding_item(self, "brassinosteroids-placeholder", selected_robot_index) then
			handle_highlight(self, "#plotHighlight", "plot", x, y)
		elseif self.board[y][x].plot_instance == hash("path-placeholder") then
			if not self.highlighted_block.id then
				if self.highlighted_block.id and self.highlighted_block.type == "plot" then
					delete_highlight(self)
				end
				create_highlight(self, "#pathHighlight", p, "path", x, y)
			elseif not (x == self.highlighted_block.x) or not (y == self.highlighted_block.y) then
				delete_highlight(self)
			end
		elseif is_on_shed(self,x,y) then
			if self.highlighted_block.id then
				delete_highlight(self)
			elseif not self.highlighted_block.id then
				local shed_dis = edge + (boardwidth-1)*blocksize
				create_highlight(self, "#shedHighlight", vmath.vector3(shed_dis,shed_dis,1), "shed", x, y)
			end
		elseif self.highlighted_block.id then
			delete_highlight(self)
		end
	elseif self.highlighted_block.id then
		delete_highlight(self)
	end
end	

function handle_highlight(self, factoryName, type, x, y)
	if not self.highlighted_block.id then 
		if is_next_to_plot(self, x, y) then
			if self.highlighted_block.id then
				delete_highlight(self)
			end
			create_highlight(self, factoryName, p, type, x, y)
		end
	elseif not (x == self.highlighted_block.x) or not (y == self.highlighted_block.y) then
		delete_highlight(self)
	end
end	

function delete_highlight(self)
	if self.highlighted_block.id ~= nil then
		go.delete(self.highlighted_block.id)
		self.highlighted_block = {id=nil,x=nil,y=nil,type=nil}
	end
end

function create_highlight(self, factoryName, p, type, x, y)
	self.highlighted_block.id = factory.create(factoryName, p)
	self.highlighted_block.type = type
	self.highlighted_block.x = x
	self.highlighted_block.y = y
end

function is_robot_holding_item(self, item, index)
	return go.get(msg.url(nil, self.robots[index].id, "RobotScript"), hash("item")) == hash(item)
end	

function can_use_pesticide(self,x,y)
	return is_robot_holding_item(self, "pesticide_placeholder", selected_robot_index) and 
	(self.board[y][x].plot_instance == hash("electric-plant-placeholder") or 
	self.board[y][x].plot_instance == hash("generic_bad_plant") or
	self.board[y][x].plot_instance == hash("explosive_plant_placeholder") or 
	self.board[y][x].plot_instance == hash("poison_plant_placeholder"))
end	

function can_use_fertilizer(self,x,y)
	return is_robot_holding_item(self, "fertilizer-placeholder", selected_robot_index) and 
	(self.board[y][x].plot_instance == hash("dirt-placeholder") or 
	self.board[y][x].plot_instance == hash("dirt-poisoned"))
end	

function can_use_steroids(self,x,y)
	return is_robot_holding_item(self, "brassinosteroids-placeholder", selected_robot_index) and 
	(self.board[y][x].plot_instance == hash("good-plant-placeholder"))
end	

function is_next_to_plot(self,x,y)
	local pos = go.get_position(self.robots[selected_robot_index].id)
	local rx = math.floor((pos.x - edge) / blocksize)
	local ry = math.floor((pos.y - bottom_edge) / blocksize)
	if ((rx + 1 == x and ry == y) or (rx-1 == x and ry == y) or (ry+1 == y and rx == x) or (ry-1 == y and rx == x)) then
		return true
	end
	return false
end	

local function moved_to_position(robot)
	robot.moving = false
end

function move_robot(self, to_tile)
	local robot = self.robots[selected_robot_index]
	if robot.can_move then
		local tile_pos = go.get_position(to_tile.id)
		local pos = vmath.vector3(tile_pos.x, tile_pos.y, .5)
		go.animate(robot.id, "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_LINEAR, 1.5, 0, moved_to_position(robot))
	end
end

function build_board(self)
	math.randomseed(os.time())
	local pos = vmath.vector3()
	local plant
	local numbadplants = 14
	local numgoodplants = 28
	local x = 0
	local y = 0
	for y = 0,boardheight-1 do
		pos.y = bottom_edge + blocksize / 2 + blocksize * y
		self.board[y] = {}
		for x = 0,boardwidth-1 do
			pos.x = edge + blocksize / 2 + blocksize * x
			pos.z = 0
			if has_value(pathtiles[y+1], x) then
				plant = hash("path-placeholder")
			elseif x == 7 and y == 8 then
				plant = hash("shed_first_version_1")
			elseif x == 8 and y == 8 then
				plant = hash("shed_first_version_2")
			elseif x == 7 and y == 7 then
				plant = hash("shed_first_version_3")
			elseif x == 8 and y == 7 then
				plant = hash("shed_first_version_4")
			else
				if numbadplants == 0 then
					numgoodplants = numgoodplants-1
					plant = goodorbadplant[1]
				elseif numgoodplants == 0 then
					numbadplants = numbadplants-1
					plant = goodorbadplant[2]
				else
					local gbpi 
					gdpi = math.random(#goodorbadplant)
					if gdpi == 1 then
						numgoodplants = numgoodplants-1
						plant = goodorbadplant[gdpi]
					else 
						numbadplants = numbadplants-1
						plant = goodorbadplant[gdpi]
					end
				end
			end
			local id = factory.create("#tileFactory", pos, null, { plot_instance = plant })
			self.board[y][x] = { id = id, plot_instance = plant,  x = x, y = y }
			if plant == hash("good-plant-placeholder") then
				table.insert(self.goodplants, id)
			elseif plant == hash("generic_bad_plant") then
				table.insert(self.badplants, id)
			end
		end
	end
	build_tilelist(self)
end


function is_on_shed(self,x,y)
	return (self.board[y][x].plot_instance == hash("shed_first_version_1") or 
	self.board[y][x].plot_instance == hash("shed_first_version_2") or 
	self.board[y][x].plot_instance == hash("shed_first_version_3") or 
	self.board[y][x].plot_instance == hash("shed_first_version_4"))
end

function has_value (array, val)
	for index, value in ipairs(array) do
		if value == val then
			return true
		end
	end

	return false
end

function show_day()
	can_click = false
	msg.post("game:/infoGUI", "day")
	day = day + 1
	timer.delay(3.4, false, function(self)
		can_click = true
	end)
end

function show_starting_info(self)
	show_day()
end

function prepare_robots(self)
	local pos = vmath.vector3(900,900,0)
	self.robots[1] = {id = factory.create("#robotFactory", pos, null, { sprite = hash("robot"), item = hash("none") }), moving = false, in_shed = true, can_move = true}
	self.robots[2] = {id = factory.create("#robotFactory", pos, null, { sprite = hash("blueRobot"), item = hash("none") }), moving = false, in_shed = true, can_move = true}
	self.robots[3] = {id = factory.create("#robotFactory", pos, null, { sprite = hash("greenRobot"), item = hash("none") }), moving = false, in_shed = true, can_move = true}
end

function start_enemy_turn(self)
	math.randomseed(os.time())
	delete_highlight(self)
	local d = 0.5
	for i, tile in ipairs(self.badplants) do repeat
		if tile.plot_instance == hash("generic_bad_plant") then
			local index
			index = math.random(#badplantchoices)
			local new_bad_plant = badplantchoices[index]
			tile.plot_instance = new_bad_plant
			self.board[tile.y][tile.x].plot_instance = hash(new_bad_plant)
			msg.post(tile.id, "play_animation", {id = hash(new_bad_plant)})
			timer.delay(d, false, function(self) end)
			break
		elseif tile.plot_instance == hash("poison_plant_placeholder") then
			local gpi
			local length_of_gp = #self.goodplants
			if length_of_gp > 0 then
				gpi = math.random(length_of_gp)
				local goodplant = self.goodplants[gpi]
				local p = go.get_position(goodplant.id)
				create_highlight(self, "#enemyHighlight", p, "enemy", goodplant.x, goodplant.y)
				local poison = {id = factory.create("#poisonFactory", vmath.vector3(tile.x, tile.y, 0), null, { sprite = hash("poisonProgectile")})}
				go.animate(poison.id, "position", go.PLAYBACK_ONCE_FORWARD, p, go.EASING_LINEAR, 1.3, 0, poison_done_moving(self, poison, goodplant))			
			end
		elseif tile.plot_instance == hash("electric-plant-placeholder") then
			msg.post(tile.id, "show_shock")
			go.animate(tile.id, "euler.z", go.PLAYBACK_ONCE_FORWARD, 3, go.EASING_LINEAR, .4, 0, electric_plant_done(tile, self))
		elseif tile.plot_instance == hash("explosive_plant_placeholder") then
			--dtile.init({ sequence = { 1,2,3,4,5,6,7,8 }, trigger = true, frequency = 30, reset = true}, "/explosion", "explosion")
			timer.delay(.5, false, function(self)
				clear_out_plot(self, tile)
			end)	
		end	
	until true end
	timer.delay(5, false, function(self)
		build_tilelist(self)
		move_robots_back(self)
	end)
end	

function move_robots_back(self)
	for i=1,3 do
		selected_robot_index = i
		if not is_robot_holding_item(self, "stunEffect", i) then
			self.robots[i].can_move = true
			move_robot(self, self.board[boardheight-1][boardwidth-1])
		end
	end
	selected_robot_index = 0
	msg.post("game:/infoGUI", "darken_screen")
	grow_plants_overnight(self)
	timer.delay(3, false, function(self)
		msg.post("game:/infoGUI", "lighten_screen")
	end)
end	

function grow_plants_overnight(self)
	math.randomseed(os.time())
	for i, empty in ipairs(self.emptyplots) do
		if empty.plot_instance == hash("dirt-placeholder") then
			local gbpi 
			gdpi = math.random(#goodorbadplant)
			plant = goodorbadplant[gdpi]
			empty.plot_instance = plant
			self.board[empty.y][empty.x].plot_instance = plant
			timer.delay(.2, false, function(self)
				msg.post(self.board[space.y][space.x].id, "play_animation", {id = hash("dirt-placeholder")})
			end)
		elseif empty.plot_instance == hash("dirt-poisoned") then
			empty.plot_instance = hash("generic_bad_plant")
			self.board[empty.y][empty.x].plot_instance = hash("generic_bad_plant")
			timer.delay(.2, false, function(self)
				msg.post(self.board[space.y][space.x].id, "play_animation", {id = hash("generic_bad_plant")})
			end)
		elseif empty.plot_instance == hash("fertilized-dirt") then
			empty.plot_instance = hash("good-plant-placeholder")
			self.board[empty.y][empty.x].plot_instance = hash("good-plant-placeholder")
			timer.delay(.2, false, function(self)
				msg.post(self.board[empty.y][empty.x].id, "play_animation", {id = hash("good-plant-placeholder")})
			end)
		end
	end	
	check_if_win_night(self)
	next_day(self)
end	

function check_if_win_day(self)
	if #self.badplants < 1 then
		won(self)
	end
end	

function check_if_win_night(self)
	if #self.goodplants < 1 then
		lost(self)
	elseif #self.badplants < 1 then
		won(self)
	end	
end	

function won(self)
	can_click = false
	end_of_game = true
	msg.post("game:/infoGUI", "won")
end

function lost(self)
	can_click = false
	end_of_game = true
	msg.post("game:/infoGUI", "lost")
end		

function next_day(self)
	show_day()
	num_pesticide = 1
	num_steroids = 1
	num_fertilizer = 1
	for i, robot in ipairs(self.robots) do
		robot.moving = false
		if not is_robot_holding_item(self, "stunEffect", i) then
			robot.in_shed = true
			robot.can_move = true
		else
			robot.in_shed = false
			robot.can_move = false
		end
	end	
	turn = "move"
end	

function poison_done_moving(self, poison, goodplant)
	print("deleting")
	go.delete(poison.id)
	goodplant.plot_instance = hash("dirt-poisoned")
	self.board[goodplant.y][goodplant.x].plot_instance = hash("dirt-poisoned")
	msg.post(goodplant.id, "play_animation", {id = hash("dirt-poisoned")})
	delete_highlight(self)
end	

function electric_plant_done(tile, self)
	go.animate(tile.id, "euler.z", go.PLAYBACK_ONCE_FORWARD, -3, go.EASING_LINEAR, .6, 0)
	timer.delay(.6, false, function(self) 
		msg.post(tile.id, "hide_shock")
		for i, robot in ipairs(self.robots) do
			if any_robots_in_viscinity(robot, tile) then
				msg.post(robot.id, "switch_item", {item="stunEffect"})
			end
		end
	end)
end	

function clear_out_plot(self, tile)
	local clear_plot = false
	for i, plot in ipairs(plots) do
		for j, space in ipairs(plot) do
			if space.x == tile.x and space.y == tile.y then
				clear_plot = true
			end	
		end	
		if clear_plot then
			for k, space in ipairs(plot) do
				space.plot_instance = hash("dirt-placeholder")
				self.board[space.y][space.x].plot_instance = hash("dirt-placeholder")
				msg.post(self.board[space.y][space.x].id, "play_animation", {id = hash("dirt-placeholder")})
			end	
		end	
	end
end	

function any_robots_in_viscinity(robot, tile)
	if (robot.x == tile.x + 1 and robot.y == tile.y) or 
		(robot.x == tile.x - 1 and robot.y == tile.y) or 
		(robot.y == tile.y + 1 and robot.x == tile.x) or 
		(robot.y == tile.y - 1 and robot.x == tile.x) or
		(robot.y == tile.y + 1 and robot.x == tile.x + 1) or
		(robot.y == tile.y - 1 and robot.x == tile.x - 1) or
		(robot.y == tile.y + 1 and robot.x == tile.x - 1) or
		(robot.y == tile.y - 1 and robot.x == tile.x + 1) then
			return true
		end
	return false	
end	

function on_message(self, message_id, message, sender)
	if message_id == hash("change_turn") then
		turn = message.turn
	elseif message_id == hash("can_click") then
		can_click = message.bool
	elseif message_id == hash("item_selected") then
		if self.robots[selected_robot_index] then 
			local robot_x = go.get_position(self.robots[selected_robot_index].id).x
			local robot_y = go.get_position(self.robots[selected_robot_index].id).y
			local x = math.floor((robot_x - edge) / blocksize)
			local y = math.floor((robot_y - bottom_edge) / blocksize)
			if is_on_shed(self, x, y) then
				msg.post(self.robots[selected_robot_index].id, "switch_item", {item=message.item})
			end
		end
	elseif message_id == hash("remove_item") then
		if self.robots[selected_robot_index] then 
			local robot_x = go.get_position(self.robots[selected_robot_index].id).x
			local robot_y = go.get_position(self.robots[selected_robot_index].id).y
			local x = math.floor((robot_x - edge) / blocksize)
			local y = math.floor((robot_y - bottom_edge) / blocksize)
			if is_on_shed(self, x, y) then
				msg.post(self.robots[selected_robot_index].id, "remove_item")
			end
		end
	end
end
