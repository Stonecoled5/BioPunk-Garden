function init(self)
	-- self.life = 1
	self.popupUp = true
	self.turn = 1
	self.gridOffsetX = 80
	self.gridOffsetY = 5
	self.placedFirstRobot = false
	self.doingSomething = false
	self.moveToPos = vmath.vector3(0,0,0)
	self.speed = vmath.vector3(0,0,0)
	--go.set_position(vmath.vector3(500,200,0))
	-- self.current_animation = hash("logo")
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
end

function on_message(self, message_id, message, sender)
	if message_id == hash("down") then
		self.popupUp = false
	end
end

function on_input(self, action_id, action)
-- 	if action_id == hash("touch") and action.pressed and not self.popupUp then
-- 		local x = math.floor(action.x)  --covert action.x to closest int
-- 		local y = math.floor(action.y)  --covert action.y to closest int
-- 		if self.placedFirstRobot then
-- 			for i = 1, 8 do
-- 				TILE.x = i + 1
-- 				for j = 1, 8 do
-- 					TILE.y = j + 1
-- 					local tile_x = TILE.x * TILE_SIZE
-- 					local tile_y = TILE.y * TILE_SIZE
-- 
-- 					local next_x_pos = (TILE.x + 2) * TILE_SIZE
-- 					local next_y_pos = (TILE.y + 2) * TILE_SIZE
-- 					local next_x_neg = (TILE.x - 2) * TILE_SIZE
-- 					local next_y_neg = (TILE.y - 2) * TILE_SIZE
-- 
-- 					local touches_x = ((x > tile_x) and (x < next_x_pos) and next_x_pos < 8*90) or ((x < tile_x) and (x > next_x_neg) and (next_x_neg > 0))
-- 					local touches_y = ((y > tile_y) and (y < next_y_pos) and next_y_pos < 8*90) or ((y < tile_y) and (y > next_y_neg) and (next_y_neg > 0))
-- 
-- 					if touches_x and touches_y then  --if the tile is the required tile
-- 						flipTileforRobotMove(ROBOT_ONE, math.floor((x-self.gridOffsetX)/TILE_SIZE), math.floor((y-self.gridOffsetY)/TILE_SIZE), self.placedFirstRobot)
-- 						print("flip")
-- 						--flipTileforRobotMove(ROBOT_TWO, x, y)
-- 						--flipTileforRobotMove(ROBOT_THREE, x, y)
-- 						break
-- 					end
-- 				end
-- 			end
-- 		end
-- 		if not self.placedFirstRobot then
-- 			if x < 615 and x > 80 and y > 897 and y < 1430 then
-- 				ROBOT_ONE.isSelected = true
-- 				ROBOT_ONE.canMove = true
-- 				flipTileforRobotMove(ROBOT_ONE, math.floor((x-self.gridOffsetX)/TILE_SIZE), math.floor((y-self.gridOffsetY)/TILE_SIZE), self.placedFirstRobot)
-- 				self.placedFirstRobot = true
-- 			end
-- 		end
	--end
end

local function play_animation(self, animation)
	if self.current_animation ~= animation then
		self.current_animation = animation
		msg.post("#sprite", "play_animation", {id = animation})
	end
end	

function flipTileforRobotMove(robot,x,y, first)
	-- if robot.isSelected and robot.alive and robot.canMove then
	-- 	print(robot.x)
	-- 	print(robot.y)
	-- 	print(x)
	-- 	print(y)
	-- 	if first then
	-- 		tilemap.set_tile("#TileMap", hash("robot"), robot.x, robot.y , 0)
	-- 	end
	-- 	tilemap.set_tile("#TileMap", hash("robot"), x, y , 5) --set the current tile to some other tile
	-- 	robot.x = x
	-- 	robot.y = y
	-- 	robot.canMove = false
	-- 	robot.isSelected = false
	-- end
end

function update(self, dt)
	--msg.post("@render:", "draw_text", {text= "Turn " .. self.turn, position = vmath.vector3(2000,1400,0)})
	-- if (self.upClicked and go.get_position().y > self.moveToPos.y) then
	-- 	self.upClicked = false
	-- 	self.doingSomething = false
	-- 	self.speed.y = 0
	-- 	go.set_position(vmath.vector3(go.get_position().x, math.floor(go.get_position().y), 0))
	-- end
	-- if (self.downClicked and go.get_position().y < self.moveToPos.y) then
	-- 	self.downClicked = false
	-- 	self.doingSomething = false
	-- 	self.speed.y = 0
	-- 	go.set_position(vmath.vector3(go.get_position().x, math.ceil(go.get_position().y), 0))
	-- end
	-- if (self.rightClicked and go.get_position().x > self.moveToPos.x) then
	-- 	self.rightClicked = false
	-- 	self.doingSomething = false
	-- 	self.speed.x = 0
	-- 	go.set_position(vmath.vector3(math.floor(go.get_position().x), go.get_position().y, 0))
	-- end
	-- if (self.leftClicked and go.get_position().x < self.moveToPos.x) then
	-- 	self.leftClicked = false
	-- 	self.doingSomething = false
	-- 	self.speed.x = 0
	-- 	go.set_position(vmath.vector3(math.ceil(go.get_position().x), go.get_position().y, 0))
	-- end
	--sprite.set_hflip("#sprite", self.speed.x < 0)
	--go.set_position(go.get_position() + self.speed*dt)
end

-- function on_input(self, action_id, action)
-- 	if action_id == hash("left") then
-- 		if action.pressed and not self.doingSomething then
-- 			self.doingSomething = true
-- 			self.moveToPos = vmath.vector3(go.get_position().x - 100, go.get_position().y, 0)
-- 			print(self.moveToPos)
-- 			self.speed.x = -500
-- 			self.movesLeft = self.movesLeft - 1
-- 			self.leftClicked = true
-- 			--play_animation(self, hash("wizard_walk"))
-- 			--elseif action.released then
-- 			--self.speed.x = 0
-- 			-- play_animation(self, hash("wizard_idle"))
-- 		end
-- 		return true
-- 	elseif action_id == hash("right") then
-- 		if action.pressed  and not self.doingSomething then
-- 			self.doingSomething = true
-- 			self.moveToPos = vmath.vector3(go.get_position().x + 100, go.get_position().y, 0)
-- 			print(self.moveToPos)
-- 			self.speed.x = 500
-- 			self.movesLeft = self.movesLeft - 1
-- 			self.rightClicked = true
-- 			-- play_animation(self, hash("wizard_walk"))
-- 		end
-- 		return true
-- 	elseif action_id == hash("up") then
-- 		if action.pressed  and not self.doingSomething then
-- 			self.doingSomething = true
-- 			self.moveToPos = vmath.vector3(go.get_position().x, go.get_position().y + 100, 0)
-- 			print(self.moveToPos)
-- 			self.speed.y = 500
-- 			self.movesLeft = self.movesLeft - 1
-- 			self.upClicked = true
-- 			-- play_animation(self, hash("wizard_walk"))
-- 		end
-- 		return true
-- 	elseif action_id == hash("down") then
-- 		if action.pressed and not self.doingSomething then
-- 			self.doingSomething = true
-- 			self.moveToPos = vmath.vector3(go.get_position().x, go.get_position().y - 100, 0)
-- 			print(self.moveToPos)
-- 			self.speed.y = -500
-- 			self.movesLeft = self.movesLeft - 1
-- 			self.downClicked = true
-- 			-- play_animation(self, hash("wizard_walk"))
-- 		end
-- 		return true
-- 	end
-- end